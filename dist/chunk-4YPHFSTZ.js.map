{"version":3,"sources":["../src/middleware/index.ts","../src/http/executor.ts","../src/mcp/server.ts","../src/config/loader.ts"],"sourcesContent":["import type { HttpRequestSpec } from '../config/loader.js';\n\nexport type MiddlewareContext = {\n  toolName: string;\n  args: Record<string, unknown>;\n};\n\nexport type PreMiddleware = (spec: HttpRequestSpec, context: MiddlewareContext) => Promise<HttpRequestSpec> | HttpRequestSpec;\nexport type PostMiddleware = (result: { status: number; headers: Record<string, string | string[]>; body: unknown }, context: MiddlewareContext) => Promise<{ status: number; headers: Record<string, string | string[]>; body: unknown }> | { status: number; headers: Record<string, string | string[]>; body: unknown };\n\n// Example middleware functions\nexport const addAuthHeader: PreMiddleware = (spec, context) => {\n  return {\n    ...spec,\n    headers: {\n      ...spec.headers,\n      'Authorization': 'Bearer example-token',\n    },\n  };\n};\n\nexport const logRequest: PreMiddleware = async (spec, context) => {\n  console.error(`[${context.toolName}] ${spec.method} ${spec.url}`);\n  return spec;\n};\n\nexport const logResponse: PostMiddleware = async (result, context) => {\n  console.error(`[${context.toolName}] Response: ${result.status}`);\n  return result;\n};\n\nexport const addTimestamp: PreMiddleware = (spec, context) => {\n  return {\n    ...spec,\n    headers: {\n      ...spec.headers,\n      'X-Timestamp': new Date().toISOString(),\n    },\n  };\n};\n\nexport const validateResponse: PostMiddleware = async (result, context) => {\n  if (result.status >= 400) {\n    throw new Error(`HTTP ${result.status}: ${JSON.stringify(result.body)}`);\n  }\n  return result;\n};\n","import { request as httpRequest } from 'node:http';\nimport { request as httpsRequest } from 'node:https';\nimport { URL } from 'node:url';\nimport type { HttpRequestSpec } from '../config/loader.js';\n\nexport async function executeHttp(spec: HttpRequestSpec): Promise<{ status: number; headers: Record<string, string | string[]>; body: unknown }> {\n  const base = new URL(spec.url);\n  if (spec.query) {\n    for (const [k, v] of Object.entries(spec.query)) base.searchParams.set(k, String(v));\n  }\n\n  const isHttps = base.protocol === 'https:';\n  const reqFn = isHttps ? httpsRequest : httpRequest;\n\n  const payload =\n    spec.body === undefined || spec.body === null\n      ? undefined\n      : typeof spec.body === 'string' || Buffer.isBuffer(spec.body)\n        ? spec.body\n        : Buffer.from(JSON.stringify(spec.body));\n\n  const headers = { ...(spec.headers ?? {}) } as Record<string, string>;\n  if (payload && !headers['content-type']) headers['content-type'] = 'application/json';\n  if (payload && !headers['content-length']) headers['content-length'] = String(Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload));\n\n  return new Promise((resolve, reject) => {\n    const req = reqFn(\n      {\n        method: spec.method,\n        protocol: base.protocol,\n        hostname: base.hostname,\n        port: base.port || (isHttps ? 443 : 80),\n        path: base.pathname + base.search,\n        headers,\n      },\n      (res) => {\n        const chunks: Buffer[] = [];\n        res.on('data', (c) => chunks.push(Buffer.from(c)));\n        res.on('end', () => {\n          const raw = Buffer.concat(chunks).toString('utf8');\n          let parsed: unknown = raw;\n          const contentType = String(res.headers['content-type'] || '');\n          if (contentType.includes('application/json')) {\n            try {\n              parsed = JSON.parse(raw);\n            } catch {\n              parsed = raw;\n            }\n          }\n          resolve({\n            status: res.statusCode || 0,\n            headers: res.headers as Record<string, string | string[]>,\n            body: parsed,\n          });\n        });\n      },\n    );\n\n    req.on('error', reject);\n    if (payload) req.write(payload);\n    req.end();\n  });\n}\n\n\n","import { executeHttp } from '../http/executor.js';\nimport type { ChunaConfig, ToolConfig, PreMiddleware, PostMiddleware, MiddlewareContext, HttpRequestSpec } from '../config/loader.js';\nimport * as middleware from '../middleware/index.js';\n\ntype StartOptions = { config: ChunaConfig };\n\ntype McpTool = {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  handler: (args: Record<string, unknown>) => Promise<{ content: unknown }>;\n};\n\nfunction getMiddlewareFunction(name: string): PreMiddleware | PostMiddleware {\n  const fn = (middleware as any)[name];\n  if (!fn || typeof fn !== 'function') {\n    throw new Error(`Middleware function \"${name}\" not found. Available: ${Object.keys(middleware).join(', ')}`);\n  }\n  return fn;\n}\n\nfunction buildToolFromConfig(tool: ToolConfig): McpTool {\n  return {\n    name: tool.name,\n    description: tool.description,\n    handler: async (args) => {\n      if (!/^https?:\\/\\//i.test(tool.url)) {\n        throw new Error(`Tool ${tool.name} requires an absolute URL (got: ${tool.url})`);\n      }\n\n      const context: MiddlewareContext = {\n        toolName: tool.name,\n        args,\n      };\n\n      // Start with the base HTTP spec\n      let httpSpec: HttpRequestSpec = {\n        method: tool.method,\n        url: tool.url,\n        headers: tool.headers,\n        query: tool.query,\n        body: tool.body,\n      };\n\n      // Apply pre-middleware\n      if (tool.preMiddleware) {\n        for (const middlewareName of tool.preMiddleware) {\n          const preFn = getMiddlewareFunction(middlewareName) as PreMiddleware;\n          httpSpec = await preFn(httpSpec, context);\n        }\n      }\n\n      // Execute HTTP request\n      const result = await executeHttp(httpSpec);\n\n      // Apply post-middleware\n      let finalResult = result;\n      if (tool.postMiddleware) {\n        for (const middlewareName of tool.postMiddleware) {\n          const postFn = getMiddlewareFunction(middlewareName) as PostMiddleware;\n          finalResult = await postFn(finalResult, context);\n        }\n      }\n\n      return { content: finalResult };\n    },\n  };\n}\n\nexport async function startMcpServer(options: StartOptions): Promise<void> {\n  const tools = options.config.tools.map((t) => buildToolFromConfig(t));\n\n  // Minimal MCP stdio protocol shim: register and handle tool calls.\n  // For v1, support a tiny subset sufficient for Cursor/Claude MCP clients.\n  process.stdin.setEncoding('utf8');\n  let buffer = '';\n\n  async function handleMessage(message: any): Promise<void> {\n    if (message?.method === 'tools/list') {\n      const toolList = tools.map((t) => ({ name: t.name, description: t.description }));\n      write({ jsonrpc: '2.0', id: message.id, result: { tools: toolList } });\n      return;\n    }\n    if (message?.method === 'tools/call') {\n      const params = message.params as { name: string; arguments?: Record<string, unknown> };\n      const tool = tools.find((t) => t.name === params.name);\n      if (!tool) {\n        write({ jsonrpc: '2.0', id: message.id, error: { code: -32601, message: `Tool not found: ${params.name}` } });\n        return;\n      }\n      try {\n        const result = await tool.handler(params.arguments ?? {});\n        write({ jsonrpc: '2.0', id: message.id, result: { content: result.content } });\n      } catch (error: any) {\n        write({ jsonrpc: '2.0', id: message.id, error: { code: -32000, message: String(error?.message ?? error) } });\n      }\n      return;\n    }\n    // Basic reply for other methods\n    write({ jsonrpc: '2.0', id: message.id, result: null });\n  }\n\n  function write(obj: any): void {\n    const payload = JSON.stringify(obj);\n    const header = `Content-Length: ${Buffer.byteLength(payload, 'utf8')}\\r\\n\\r\\n`;\n    process.stdout.write(header + payload);\n  }\n\n  process.stdin.on('data', (chunk) => {\n    buffer += chunk;\n    while (true) {\n      const sepIndex = buffer.indexOf('\\r\\n\\r\\n');\n      if (sepIndex === -1) break;\n      const headerBlock = buffer.slice(0, sepIndex);\n      const contentLengthMatch = /Content-Length:\\s*(\\d+)/i.exec(headerBlock);\n      if (!contentLengthMatch) {\n        buffer = buffer.slice(sepIndex + 4);\n        continue;\n      }\n      const contentLength = Number(contentLengthMatch[1]);\n      const start = sepIndex + 4;\n      const end = start + contentLength;\n      if (buffer.length < end) break;\n      const body = buffer.slice(start, end);\n      buffer = buffer.slice(end);\n      try {\n        const msg = JSON.parse(body);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        handleMessage(msg);\n      } catch {\n        // ignore malformed messages\n      }\n    }\n  });\n}","import fs from 'node:fs/promises';\nimport path from 'node:path';\n\n// Middleware types - functions exported from middleware/index.ts\nexport type PreMiddleware = (spec: HttpRequestSpec, context: MiddlewareContext) => Promise<HttpRequestSpec> | HttpRequestSpec;\nexport type PostMiddleware = (result: { status: number; headers: Record<string, string | string[]>; body: unknown }, context: MiddlewareContext) => Promise<{ status: number; headers: Record<string, string | string[]>; body: unknown }> | { status: number; headers: Record<string, string | string[]>; body: unknown };\n\nexport type MiddlewareContext = {\n  toolName: string;\n  args: Record<string, unknown>;\n};\n\nexport type HttpRequestSpec = {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  url: string;\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n  body?: unknown;\n};\n\nexport type ToolConfig = {\n  name: string;\n  description?: string;\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  url: string;\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n  body?: unknown;\n  preMiddleware?: string[];\n  postMiddleware?: string[];\n};\n\nexport type ChunaConfig = {\n  version?: number;\n  baseUrl?: string;\n  tools: ToolConfig[];\n};\n\nfunction substituteEnv(input: unknown): unknown {\n  if (typeof input === 'string') {\n    return input.replace(/\\$\\{ENV:([A-Z0-9_]+)\\}/g, (_m, varName: string) => {\n      const value = process.env[varName];\n      return value ?? '';\n    });\n  }\n  if (Array.isArray(input)) return input.map((v) => substituteEnv(v));\n  if (input && typeof input === 'object') {\n    const obj = input as Record<string, unknown>;\n    const out: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(obj)) out[k] = substituteEnv(v);\n    return out;\n  }\n  return input;\n}\n\nasync function readJson(filePath: string): Promise<any> {\n  const raw = await fs.readFile(filePath, 'utf8');\n  const json = JSON.parse(raw);\n  return substituteEnv(json);\n}\n\nexport async function loadConfigFromPath(configPath: string): Promise<ChunaConfig> {\n  const stat = await fs.stat(configPath);\n  if (stat.isDirectory()) {\n    const toolsPath = path.join(configPath, 'tools.json');\n    const parsed = await readJson(toolsPath);\n    // Support two shapes:\n    // 1) { baseUrl?: string, tools: ToolConfig[] }\n    // 2) ToolConfig[] (legacy) -> wrap into { tools }\n    if (Array.isArray(parsed)) {\n      return { version: 1, tools: parsed } as ChunaConfig;\n    }\n    const obj = (parsed ?? {}) as Partial<ChunaConfig> & { tools?: ToolConfig[] };\n    return {\n      version: obj.version ?? 1,\n      baseUrl: obj.baseUrl,\n      tools: obj.tools ?? [],\n    } as ChunaConfig;\n  }\n  return (await readJson(configPath)) as ChunaConfig;\n}\n\n\n"],"mappings":"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","names":[]}