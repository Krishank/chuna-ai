{"version":3,"sources":["../src/http/executor.ts","../src/mcp/server.ts","../src/config/loader.ts"],"sourcesContent":["import { request as httpRequest } from 'node:http';\nimport { request as httpsRequest } from 'node:https';\nimport { URL } from 'node:url';\n\nexport type HttpRequestSpec = {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  url: string;\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n  body?: unknown;\n};\n\nexport async function executeHttp(spec: HttpRequestSpec): Promise<{ status: number; headers: Record<string, string | string[]>; body: unknown }> {\n  const base = new URL(spec.url);\n  if (spec.query) {\n    for (const [k, v] of Object.entries(spec.query)) base.searchParams.set(k, String(v));\n  }\n\n  const isHttps = base.protocol === 'https:';\n  const reqFn = isHttps ? httpsRequest : httpRequest;\n\n  const payload =\n    spec.body === undefined || spec.body === null\n      ? undefined\n      : typeof spec.body === 'string' || Buffer.isBuffer(spec.body)\n        ? spec.body\n        : Buffer.from(JSON.stringify(spec.body));\n\n  const headers = { ...(spec.headers ?? {}) } as Record<string, string>;\n  if (payload && !headers['content-type']) headers['content-type'] = 'application/json';\n  if (payload && !headers['content-length']) headers['content-length'] = String(Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload));\n\n  return new Promise((resolve, reject) => {\n    const req = reqFn(\n      {\n        method: spec.method,\n        protocol: base.protocol,\n        hostname: base.hostname,\n        port: base.port || (isHttps ? 443 : 80),\n        path: base.pathname + base.search,\n        headers,\n      },\n      (res) => {\n        const chunks: Buffer[] = [];\n        res.on('data', (c) => chunks.push(Buffer.from(c)));\n        res.on('end', () => {\n          const raw = Buffer.concat(chunks).toString('utf8');\n          let parsed: unknown = raw;\n          const contentType = String(res.headers['content-type'] || '');\n          if (contentType.includes('application/json')) {\n            try {\n              parsed = JSON.parse(raw);\n            } catch {\n              parsed = raw;\n            }\n          }\n          resolve({\n            status: res.statusCode || 0,\n            headers: res.headers as Record<string, string | string[]>,\n            body: parsed,\n          });\n        });\n      },\n    );\n\n    req.on('error', reject);\n    if (payload) req.write(payload);\n    req.end();\n  });\n}\n\n\n","import { executeHttp } from '../http/executor.js';\nimport type { ChunaConfig, ToolConfig } from '../config/loader.js';\n\ntype StartOptions = { config: ChunaConfig };\n\ntype McpTool = {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  handler: (args: Record<string, unknown>) => Promise<{ content: unknown }>;\n};\n\nfunction buildToolFromConfig(tool: ToolConfig, baseUrl?: string): McpTool {\n  return {\n    name: tool.name,\n    description: tool.description,\n    handler: async (args) => {\n      const url = tool.url.startsWith('http') ? tool.url : (baseUrl ? new URL(tool.url, baseUrl).toString() : tool.url);\n      const result = await executeHttp({\n        method: tool.method,\n        url,\n        headers: tool.headers,\n        query: tool.query,\n        body: tool.body,\n      });\n      return { content: { status: result.status, headers: result.headers, body: result.body } };\n    },\n  };\n}\n\nexport async function startMcpServer(options: StartOptions): Promise<void> {\n  const tools = options.config.tools.map((t) => buildToolFromConfig(t, options.config.baseUrl));\n\n  // Minimal MCP stdio protocol shim: register and handle tool calls.\n  // For v1, support a tiny subset sufficient for Cursor/Claude MCP clients.\n  process.stdin.setEncoding('utf8');\n  let buffer = '';\n\n  async function handleMessage(message: any): Promise<void> {\n    if (message?.method === 'tools/list') {\n      const toolList = tools.map((t) => ({ name: t.name, description: t.description }));\n      write({ jsonrpc: '2.0', id: message.id, result: { tools: toolList } });\n      return;\n    }\n    if (message?.method === 'tools/call') {\n      const params = message.params as { name: string; arguments?: Record<string, unknown> };\n      const tool = tools.find((t) => t.name === params.name);\n      if (!tool) {\n        write({ jsonrpc: '2.0', id: message.id, error: { code: -32601, message: `Tool not found: ${params.name}` } });\n        return;\n      }\n      try {\n        const result = await tool.handler(params.arguments ?? {});\n        write({ jsonrpc: '2.0', id: message.id, result: { content: result.content } });\n      } catch (error: any) {\n        write({ jsonrpc: '2.0', id: message.id, error: { code: -32000, message: String(error?.message ?? error) } });\n      }\n      return;\n    }\n    // Basic reply for other methods\n    write({ jsonrpc: '2.0', id: message.id, result: null });\n  }\n\n  function write(obj: any): void {\n    const payload = JSON.stringify(obj);\n    const header = `Content-Length: ${Buffer.byteLength(payload, 'utf8')}\\r\\n\\r\\n`;\n    process.stdout.write(header + payload);\n  }\n\n  process.stdin.on('data', (chunk) => {\n    buffer += chunk;\n    while (true) {\n      const sepIndex = buffer.indexOf('\\r\\n\\r\\n');\n      if (sepIndex === -1) break;\n      const headerBlock = buffer.slice(0, sepIndex);\n      const contentLengthMatch = /Content-Length:\\s*(\\d+)/i.exec(headerBlock);\n      if (!contentLengthMatch) {\n        buffer = buffer.slice(sepIndex + 4);\n        continue;\n      }\n      const contentLength = Number(contentLengthMatch[1]);\n      const start = sepIndex + 4;\n      const end = start + contentLength;\n      if (buffer.length < end) break;\n      const body = buffer.slice(start, end);\n      buffer = buffer.slice(end);\n      try {\n        const msg = JSON.parse(body);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        handleMessage(msg);\n      } catch {\n        // ignore malformed messages\n      }\n    }\n  });\n}\n\n\n","import fs from 'node:fs/promises';\nimport path from 'node:path';\n\nexport type ToolConfig = {\n  name: string;\n  description?: string;\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  url: string;\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n  body?: unknown;\n};\n\nexport type ChunaConfig = {\n  version?: number;\n  baseUrl?: string;\n  tools: ToolConfig[];\n};\n\nfunction substituteEnv(input: unknown): unknown {\n  if (typeof input === 'string') {\n    return input.replace(/\\$\\{ENV:([A-Z0-9_]+)\\}/g, (_m, varName: string) => {\n      const value = process.env[varName];\n      return value ?? '';\n    });\n  }\n  if (Array.isArray(input)) return input.map((v) => substituteEnv(v));\n  if (input && typeof input === 'object') {\n    const obj = input as Record<string, unknown>;\n    const out: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(obj)) out[k] = substituteEnv(v);\n    return out;\n  }\n  return input;\n}\n\nasync function readJson(filePath: string): Promise<any> {\n  const raw = await fs.readFile(filePath, 'utf8');\n  const json = JSON.parse(raw);\n  return substituteEnv(json);\n}\n\nexport async function loadConfigFromPath(configPath: string): Promise<ChunaConfig> {\n  const stat = await fs.stat(configPath);\n  if (stat.isDirectory()) {\n    const mainPath = path.join(configPath, 'main.json');\n    const toolsPath = path.join(configPath, 'tools.json');\n    const main: Partial<ChunaConfig> = (await readJson(mainPath)) ?? {};\n    const tools: ToolConfig[] = (await readJson(toolsPath)) ?? [];\n    return {\n      version: 1,\n      tools,\n      ...main,\n    } as ChunaConfig;\n  }\n  return (await readJson(configPath)) as ChunaConfig;\n}\n\n\n"],"mappings":"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","names":["URL"]}